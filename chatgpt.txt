por mas que este logueado o no. No me estan abriendo estas paginas:
            <Route path="/admin" element={<ProtectedRoute element={<AdminPanel />} />} />
            <Route path="/admin/productos" element={<ProtectedRoute element={<ProductList />} />} />
            <Route path="/admin/create-product" element={<ProtectedRoute element={<CreateProduct />} />} />
            <Route path="/admin/producto/:id" element={<ProtectedRoute element={<EditProduct />} />} />
            <Route path="/admin/pedidos" element={<ProtectedRoute element={<OrdersList />} />} />
            <Route path="/admin/ordenes" element={<ProtectedRoute element={<Ordenes />} />} />





1ï¸âƒ£ âœ… Finalizar compra: Crear un proceso donde los usuarios confirmen su compra antes de pagar.
2ï¸âƒ£ Integrar Mercado Pago: Configurar pagos online para que los clientes puedan pagar sus compras.
3ï¸âƒ£ âœ… Seguimiento de compra: Permitir que los clientes revisen el estado de sus pedidos.
4ï¸âƒ£ Control de stock: Ajustar la cantidad de productos disponibles al realizar una compra.
5ï¸âƒ£ âœ… Redireccion en caso de fallar. 404
6ï¸âƒ£ Ver Tutorial, reproducir video de youtube

--------------------
import { createContext, useContext, useEffect, useState } from "react";
import { onAuthStateChanged } from "firebase/auth";
import { auth, db } from "../firebase";
import { doc, getDoc } from "firebase/firestore";
âœ… Importaciones necesarias:

createContext, useContext, useEffect, useState: Para manejar el contexto y la autenticaciÃ³n en React.

onAuthStateChanged: Detecta cambios en el estado de autenticaciÃ³n de Firebase.

auth: Instancia de Firebase Authentication.

db, doc, getDoc: Para acceder a Firestore y obtener el rol del usuario.



const AuthContext = createContext();
âœ… Creamos el contexto:
Esto permite que toda la aplicaciÃ³n acceda a user, isAdmin y loading sin necesidad de pasarlos como props.
export const AuthProvider = ({ children }) => {
âœ… Este componente envuelve la aplicaciÃ³n y gestiona el estado de autenticaciÃ³n.

  const [user, setUser] = useState(null);
  const [isAdmin, setIsAdmin] = useState(false);
  const [loading, setLoading] = useState(true);
âœ… Estados principales:

user: Guarda la informaciÃ³n del usuario autenticado.

isAdmin: Indica si el usuario tiene el rol de administrador.

loading: Indica si aÃºn estamos cargando la autenticaciÃ³n.


--
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
âœ… onAuthStateChanged detecta si hay un usuario autenticado.

Se ejecuta cuando Firebase cambia el estado del usuario.

Si firebaseUser es null, significa que el usuario no ha iniciado sesiÃ³n o se deslogueÃ³.
--
  try {
        console.log("Firebase user:", firebaseUser);

        if (!firebaseUser) {
          setUser(null);
          setIsAdmin(false);
          setLoading(false);
          return;
        }
âœ… Si no hay usuario, lo reseteamos.

setUser(null): No hay usuario autenticado.

setIsAdmin(false): No puede ser admin si no estÃ¡ autenticado.

setLoading(false): Finalizamos la carga.

return;: Terminamos la ejecuciÃ³n para evitar consultar Firestore innecesariamente.


--
        const userRef = doc(db, "usuarios", firebaseUser.uid);
        const userSnap = await getDoc(userRef);
        const userData = userSnap.exists() ? userSnap.data() : null;

        console.log("Documento Firestore del usuario:", userData);
âœ… Si el usuario estÃ¡ autenticado, buscamos su informaciÃ³n en Firestore.

doc(db, "usuarios", firebaseUser.uid): Ubicamos el documento del usuario en Firestore.

await getDoc(userRef): Obtenemos los datos.

userSnap.exists() ? userSnap.data() : null: Si el documento existe, guardamos sus datos.

--

        setUser(firebaseUser);
        setIsAdmin(userData?.rol === "admin");
âœ… Guardamos los datos en el estado.

setUser(firebaseUser): Guardamos el usuario en el estado.

setIsAdmin(userData?.rol === "admin"): Si el rol en Firestore es "admin", isAdmin serÃ¡ true.
-
      } catch (error) {
        console.error("Error obteniendo usuario de Firestore:", error);
      } finally {
        setLoading(false);
      }
âœ… Manejo de errores y finalizaciÃ³n de carga.

Si algo falla en Firestore, mostramos el error.

En finally, ponemos setLoading(false) para asegurarnos de que la aplicaciÃ³n no se quede en estado de carga infinita.
--
   return () => unsubscribe();
  }, []);
âœ… Limpieza del efecto.

onAuthStateChanged devuelve una funciÃ³n para cancelar la suscripciÃ³n cuando el componente se desmonta.
--
return (
    <AuthContext.Provider value={{ user, isAdmin, loading }}>
      {!loading && children} {/* ğŸ”¹ Evita renderizar antes de que cargue */}
    </AuthContext.Provider>
  );
âœ… Retornamos el contexto con user, isAdmin y loading.

Usamos !loading && children para que la app no intente renderizar nada hasta que la autenticaciÃ³n termine de cargarse.

---
export const useAuth = () => useContext(AuthContext);
âœ… Creamos un hook useAuth() para acceder fÃ¡cilmente a user, isAdmin y loading.

--



Si necesitas proteger rutas para administradores, puedes modificar ProtectedRoute asÃ­:

jsx
Copiar
Editar
import { useAuth } from "../context/AuthContext";
import { Navigate } from "react-router-dom";

const ProtectedRoute = ({ element, adminOnly = false }) => {
  const { user, isAdmin, loading } = useAuth();

  if (loading) return <p>Cargando...</p>;

  if (!user) return <Navigate to="/login" replace />;

  if (adminOnly && !isAdmin) return <Navigate to="/" replace />;

  return element;
};

export default ProtectedRoute;
ğŸ”¹ AsÃ­ funciona:

Si adminOnly es true, solo deja pasar a admins.

Si el usuario no estÃ¡ autenticado, lo redirige a /login.

Si no es admin y la ruta es solo para admins, lo manda a /.

---

